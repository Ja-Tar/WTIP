<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <title>Wyświetlacz / Display</title>
    <link rel="stylesheet" href="template_WAW_ZACH.css">
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
</head>

<body>
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            color: white;
            font-size: 16px;
            margin: 0;
            padding: 0;
        }

        #display_box {
            overflow: hidden;
        }

        #display {
            width: 700px;
            height: fit-content;
            background-color: #283c65;
        }

        #time {
            font-weight: bolder;
            font-size: 420%;
        }

        .row {
            display: flex;
            margin-top: 0px;
            margin-bottom: 10px;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        ul {
            padding-left: 0px;
            padding-right: 0px;
        }

        li {
            list-style-type: none;
        }

        .label {
            font-style: italic;
        }

        #train_number_box {
            margin-right: 10%;
            margin-top: 5px;
        }

        #train_number {
            position: absolute;
            font-size: 190%;
            transform: translate(-2%, -15%);
        }

        .row {
            padding-left: 5px;
            padding-right: 5px;
        }

        #destination {
            font-size: 420%;
            font-weight: bolder;
            white-space: nowrap;
            overflow: hidden;
            animation-duration: 16s;
        }

        #via_stations {
            font-size: 180%;
            white-space: nowrap;
            overflow: hidden;
            transform: translate(0%, -10%);
        }

        #operator {
            font-size: 160%;
            white-space: nowrap;
            overflow: hidden;
            transform: translate(0%, -10%);
        }

        #row1,
        #row4 {
            margin-bottom: 0px;
        }

        #info_bar_box {
            width: 100%;
            height: 38px;
            margin: 0;
            background-color: #2f353d;
        }

        #info_bar {
            font-size: 160%;
            width: 100%;
            font-weight: bolder;
            font-style: italic;
        }

        #delay_box {
            margin-top: 5px;
        }

        #delay_background {
            background-color: red;
            display: flex;
            width: fit-content;
            height: 55%;
            transform: translate(0%, 10%);
        }

        #delay {
            font-size: 290%;
            font-weight: bolder;
            transform: translate(0%, -20%);
        }

        /* Scroll text */

        .box_scroll {
            display: flex;
            overflow: visible;
            white-space: nowrap;
            align-items: center;
        }

        /* Rainbow background effect */

        @keyframes rainbow {
            0% {
                background-position: 0% 82%
            }

            50% {
                background-position: 100% 19%
            }

            100% {
                background-position: 0% 82%
            }
        }

        .rainbow {
            background: linear-gradient(270deg, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00);
            background-size: 1400% 1400%;
            animation: rainbow 10s ease infinite;
        }
    </style>
    <script>
        window.addEventListener('resize', scaleDisplay);
        document.addEventListener('DOMContentLoaded', function () {
            scaleDisplay();
            replaceTemplateValues();
            firefoxCheck();
        });

        function scaleDisplay() {
            var display = document.getElementById('display');
            var scaleFactor = window.innerWidth / 700;

            display.style.transform = 'scale(' + scaleFactor + ')';
            display.style.transformOrigin = 'top left';
        }

        function replaceTemplateValues() {
            var time = document.getElementById('time');
            var trainNumber = document.getElementById('train_number');
            var destination = document.getElementById('destination');
            var viaStations = document.getElementById('via_stations');
            var operator = document.getElementById('operator');
            var infoBar = document.getElementById('info_bar');
            var infoBarBox = document.getElementById('info_bar_box');
            var delay = document.getElementById('delay');

            var urlParams = new URLSearchParams(window.location.search);

            if (!urlParams.has('time') || !urlParams.has('train_number') || !urlParams.has('destination') || !urlParams.has('operator')) {
                return;
            }

            time.innerHTML = urlParams.get('time');
            trainNumber.innerHTML = urlParams.get('train_number');
            destination.innerHTML = urlParams.get('destination');
            destination.setAttribute('data-scroll-text', urlParams.get('destination'));
            viaStations.innerHTML = urlParams.get('via_stations');
            viaStations.setAttribute('data-scroll-text', urlParams.get('via_stations'));
            operator.innerHTML = urlParams.get('operator');

            if (urlParams.has('delay') && urlParams.get('delay') != '' && urlParams.get('delay') != '0') {
                delay.innerHTML = "~" + urlParams.get('delay') + "' ";
            } else {
                delay.parentElement.parentElement.style.display = "none";
            }

            if (urlParams.has('info_bar') && urlParams.get('info_bar') != '') {
                infoBar.innerHTML = urlParams.get('info_bar');
                infoBar.setAttribute('data-scroll-text', urlParams.get('info_bar'));
                infoBarBox.style.backgroundColor = urlParams.get('colorbar');
                infoBar.style.color = urlParams.get('colorfont');

                // Easter egg (joke)
                if (urlParams.get('info_bar').toLowerCase().includes('<egon>')) {
                    infoBarBox.classList.add('rainbow');
                }
            } else {
                infoBar.parentElement.style.display = "none"
                infoBarBox.style.backgroundColor = "transparent";
            }
        }

        function scrollText() {
            const elements = document.querySelectorAll('.scroll');

            elements.forEach(element => {
                const parentWidth = element.parentElement.offsetWidth;
                const textWidth = element.offsetWidth;
                const textLength = element.textContent.length;
                const elementId = element.id;
                let maxTextLength;
                let addText = '';

                if (elementId === 'destination') {
                    maxTextLength = 17;
                    addText = '   ';
                } else if (elementId === 'via_stations') {
                    maxTextLength = 42;
                    addText = '   ';
                    if (textLength == 0) {
                        element.textContent = ' ';
                    }
                } else if (elementId === 'info_bar') {
                    maxTextLength = 44;
                    addText = '  ***  ';
                }

                if (textLength > maxTextLength) {
                    element.textContent += addText;

                    // Marquee effect infinite loop
                    const textClone = element.cloneNode(true);
                    textClone.classList.add('clone');
                    element.parentElement.appendChild(textClone);

                    const texts = gsap.utils.toArray(`#${elementId}`),
                        loop = horizontalLoop(texts, { paused: false, repeat: -1, speed: 0.6 });
                }
            });
        }

        function firefoxCheck() {
            var isFirefox = !!navigator.userAgent.match(/firefox/i);
            if (isFirefox) {
                let delay_background = document.getElementById('delay_background');
                let delay = document.getElementById('delay');
                let train_number = document.getElementById('train_number');
                let via_stations = document.getElementById('via_stations');
                let operator = document.getElementById('operator');

                delay_background.style.height = '45%';
                delay.style.transform = 'translate(0%, -37%)'
                train_number.style.transform = 'translate(-2%, -20%)'
                via_stations.style.transform = 'translate(0%, -15%)'
                operator.style.transform = 'translate(0%, -15%)'
            }
        }

        window.onload = scrollText;
    </script>
    <div id="display_box">
        <li id="display">
            <ul id="row1" class="row">
                <div id="time">00:00</div>
                <div id="delay_box">
                    <div class="label">Opóźniony / Delayed:</div>
                    <div id="delay_background">
                        <div id="delay">~5' </div>
                    </div>
                </div>
                <div id="train_number_box">
                    <div class="label">Numer / Number:</div>
                    <div id="train_number">EIE 1234</div>
                </div>
            </ul>
            <ul id="row2" class="row">
                <div class="box_scroll">
                    <div id="destination" class="scroll">Warszawa Wschodnia</div>
                </div>
            </ul>
            <ul id="row3" class="row">
                <div id="via_stations_box">
                    <div class="label">Stacje pośrednie / Via stations:</div>
                    <div class="box_scroll">
                        <div id="via_stations" class="scroll">Warszawa Centralna</div>
                    </div>
                </div>
            </ul>
            <ul id="row4" class="row">
                <div id="operator_box">
                    <div class="label">Przewoźnik / Operator:</div>
                    <div id="operator">Testowy Przewoźnik</div>
                </div>
            </ul>
            <ul id="info_bar_box" class="row">
                <div class="box_scroll">
                    <div id="info_bar" class="scroll">Ekran Testowy</div>
                </div>
            </ul>
        </li>
    </div>
    <script>
        /*
This helper function makes a group of elements animate along the x-axis in a seamless, responsive loop.

Features:
- Uses xPercent so that even if the widths change (like if the window gets resized), it should still work in most cases.
- When each item animates to the left or right enough, it will loop back to the other side
- Optionally pass in a config object with values like "speed" (default: 1, which travels at roughly 100 pixels per second), paused (boolean),  repeat, reversed, and paddingRight.
- The returned timeline will have the following methods added to it:
- next() - animates to the next element using a timeline.tweenTo() which it returns. You can pass in a vars object to control duration, easing, etc.
- previous() - animates to the previous element using a timeline.tweenTo() which it returns. You can pass in a vars object to control duration, easing, etc.
- toIndex() - pass in a zero-based index value of the element that it should animate to, and optionally pass in a vars object to control duration, easing, etc. Always goes in the shortest direction
- current() - returns the current index (if an animation is in-progress, it reflects the final index)
- times - an Array of the times on the timeline where each element hits the "starting" spot. There's also a label added accordingly, so "label1" is when the 2nd element reaches the start.
*/
        function horizontalLoop(items, config) {
            items = gsap.utils.toArray(items);
            config = config || {};
            let tl = gsap.timeline({
                repeat: config.repeat,
                paused: config.paused,
                defaults: { ease: "none" },
                onReverseComplete: () => tl.totalTime(tl.rawTime() + tl.duration() * 100),
            }),
                length = items.length,
                startX = items[0].offsetLeft,
                times = [],
                widths = [],
                xPercents = [],
                curIndex = 0,
                pixelsPerSecond = (config.speed || 1) * 100,
                snap = config.snap === false ? (v) => v : gsap.utils.snap(config.snap || 1), // some browsers shift by a pixel to accommodate flex layouts, so for example if width is 20% the first element's width might be 242px, and the next 243px, alternating back and forth. So we snap to 5 percentage points to make things look more natural
                totalWidth,
                curX,
                distanceToStart,
                distanceToLoop,
                item,
                i;
            gsap.set(items, {
                // convert "x" to "xPercent" to make things responsive, and populate the widths/xPercents Arrays to make lookups faster.
                xPercent: (i, el) => {
                    let w = (widths[i] = parseFloat(gsap.getProperty(el, "width", "px")));
                    xPercents[i] = snap(
                        (parseFloat(gsap.getProperty(el, "x", "px")) / w) * 100 +
                        gsap.getProperty(el, "xPercent")
                    );
                    return xPercents[i];
                },
            });
            gsap.set(items, { x: 0 });
            totalWidth =
                items[length - 1].offsetLeft +
                (xPercents[length - 1] / 100) * widths[length - 1] -
                startX +
                items[length - 1].offsetWidth *
                gsap.getProperty(items[length - 1], "scaleX") +
                (parseFloat(config.paddingRight) || 0);
            for (i = 0; i < length; i++) {
                item = items[i];
                curX = (xPercents[i] / 100) * widths[i];
                distanceToStart = item.offsetLeft + curX - startX;
                distanceToLoop =
                    distanceToStart + widths[i] * gsap.getProperty(item, "scaleX");
                tl.to(
                    item,
                    {
                        xPercent: snap(((curX - distanceToLoop) / widths[i]) * 100),
                        duration: distanceToLoop / pixelsPerSecond,
                    },
                    0
                )
                    .fromTo(
                        item,
                        {
                            xPercent: snap(
                                ((curX - distanceToLoop + totalWidth) / widths[i]) * 100
                            ),
                        },
                        {
                            xPercent: xPercents[i],
                            duration:
                                (curX - distanceToLoop + totalWidth - curX) / pixelsPerSecond,
                            immediateRender: false,
                        },
                        distanceToLoop / pixelsPerSecond
                    )
                    .add("label" + i, distanceToStart / pixelsPerSecond);
                times[i] = distanceToStart / pixelsPerSecond;
            }
            function toIndex(index, vars) {
                vars = vars || {};
                Math.abs(index - curIndex) > length / 2 &&
                    (index += index > curIndex ? -length : length); // always go in the shortest direction
                let newIndex = gsap.utils.wrap(0, length, index),
                    time = times[newIndex];
                if (time > tl.time() !== index > curIndex) {
                    // if we're wrapping the timeline's playhead, make the proper adjustments
                    vars.modifiers = { time: gsap.utils.wrap(0, tl.duration()) };
                    time += tl.duration() * (index > curIndex ? 1 : -1);
                }
                curIndex = newIndex;
                vars.overwrite = true;
                return tl.tweenTo(time, vars);
            }
            tl.next = (vars) => toIndex(curIndex + 1, vars);
            tl.previous = (vars) => toIndex(curIndex - 1, vars);
            tl.current = () => curIndex;
            tl.toIndex = (index, vars) => toIndex(index, vars);
            tl.times = times;
            tl.progress(1, true).progress(0, true); // pre-render for performance
            if (config.reversed) {
                tl.vars.onReverseComplete();
                tl.reverse();
            }
            return tl;
        }
    </script>
</body>

</html>